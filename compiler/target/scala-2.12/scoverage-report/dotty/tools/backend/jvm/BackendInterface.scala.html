<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          dotty/tools/backend/jvm/BackendInterface.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier;'>1 <span style=''>package scala.tools.nsc.backend.jvm
</span>2 <span style=''>
</span>3 <span style=''>import scala.collection.generic.Clearable
</span>4 <span style=''>import scala.reflect.ClassTag
</span>5 <span style=''>import scala.tools.nsc.io.AbstractFile
</span>6 <span style=''>import scala.language.implicitConversions
</span>7 <span style=''>import scala.tools.asm
</span>8 <span style=''>
</span>9 <span style=''>
</span>10 <span style=''>/* Interface to abstract over frontend inside backend.
</span>11 <span style=''> * Intended to be implemented by both scalac and dotc
</span>12 <span style=''> */
</span>13 <span style=''>abstract class BackendInterface extends BackendInterfaceDefinitions {
</span>14 <span style=''>  type Flags      = Long
</span>15 <span style=''>
</span>16 <span style=''>  type Constant   &gt;: Null &lt;: AnyRef
</span>17 <span style=''>  type Symbol     &gt;: Null &lt;: AnyRef
</span>18 <span style=''>  type Type       &gt;: Null &lt;: AnyRef
</span>19 <span style=''>  type Annotation &gt;: Null &lt;: AnyRef
</span>20 <span style=''>  type Tree       &gt;: Null &lt;: AnyRef
</span>21 <span style=''>  type Modifiers  &gt;: Null &lt;: AnyRef
</span>22 <span style=''>  type TypeDef    &gt;: Null &lt;: Tree
</span>23 <span style=''>  type Apply      &gt;: Null &lt;: Tree
</span>24 <span style=''>  type Select     &gt;: Null &lt;: Tree
</span>25 <span style=''>  type TypeApply  &gt;: Null &lt;: Tree
</span>26 <span style=''>  type ClassDef   &gt;: Null &lt;: Tree
</span>27 <span style=''>  type Try        &gt;: Null &lt;: Tree
</span>28 <span style=''>  type Assign     &gt;: Null &lt;: Tree
</span>29 <span style=''>  type Ident      &gt;: Null &lt;: Tree
</span>30 <span style=''>  type If         &gt;: Null &lt;: Tree
</span>31 <span style=''>  type LabelDef   &gt;: Null &lt;: Tree
</span>32 <span style=''>  type ValDef     &gt;: Null &lt;: Tree
</span>33 <span style=''>  type Throw      &gt;: Null &lt;: Tree
</span>34 <span style=''>  type Return     &gt;: Null &lt;: Tree
</span>35 <span style=''>  type Literal    &gt;: Null &lt;: Tree
</span>36 <span style=''>  type Block      &gt;: Null &lt;: Tree
</span>37 <span style=''>  type Typed      &gt;: Null &lt;: Tree
</span>38 <span style=''>  type ArrayValue &gt;: Null &lt;: Tree
</span>39 <span style=''>  type Match      &gt;: Null &lt;: Tree
</span>40 <span style=''>  type This       &gt;: Null &lt;: Tree
</span>41 <span style=''>  type CaseDef    &gt;: Null &lt;: Tree
</span>42 <span style=''>  type Alternative &gt;: Null &lt;: Tree
</span>43 <span style=''>  type DefDef     &gt;: Null &lt;: Tree
</span>44 <span style=''>  type ModuleDef  &gt;: Null &lt;: Tree
</span>45 <span style=''>  type Template   &gt;: Null &lt;: Tree
</span>46 <span style=''>  type Name       &gt;: Null &lt;: AnyRef
</span>47 <span style=''>  type Position
</span>48 <span style=''>  type CompilationUnit &lt;: AnyRef
</span>49 <span style=''>  type Bind         &gt;: Null &lt;: Tree
</span>50 <span style=''>  type New          &gt;: Null &lt;: Tree
</span>51 <span style=''>  type ApplyDynamic &gt;: Null &lt;: Tree
</span>52 <span style=''>  type Super       &gt;: Null &lt;: Tree
</span>53 <span style=''>  type Closure     &gt;: Null &lt;: Tree
</span>54 <span style=''>
</span>55 <span style=''>
</span>56 <span style=''>  implicit val TypeDefTag: ClassTag[TypeDef]
</span>57 <span style=''>  implicit val ApplyTag: ClassTag[Apply]
</span>58 <span style=''>  implicit val SelectTag: ClassTag[Select]
</span>59 <span style=''>
</span>60 <span style=''>  implicit val TypeApplyTag: ClassTag[TypeApply]
</span>61 <span style=''>  implicit val ClassDefTag: ClassTag[ClassDef]
</span>62 <span style=''>  implicit val TryTag: ClassTag[Try]
</span>63 <span style=''>  implicit val AssignTag: ClassTag[Assign]
</span>64 <span style=''>  implicit val IdentTag: ClassTag[Ident]
</span>65 <span style=''>  implicit val IfTag: ClassTag[If]
</span>66 <span style=''>  implicit val LabelDefTag: ClassTag[LabelDef]
</span>67 <span style=''>  implicit val ValDefTag: ClassTag[ValDef]
</span>68 <span style=''>  implicit val ThrowTag: ClassTag[Throw]
</span>69 <span style=''>  implicit val ReturnTag: ClassTag[Return]
</span>70 <span style=''>  implicit val LiteralTag: ClassTag[Literal]
</span>71 <span style=''>  implicit val BlockTag: ClassTag[Block]
</span>72 <span style=''>  implicit val TypedTag: ClassTag[Typed]
</span>73 <span style=''>  implicit val ArrayValueTag: ClassTag[ArrayValue]
</span>74 <span style=''>  implicit val MatchTag: ClassTag[Match]
</span>75 <span style=''>  implicit val CaseDefTag: ClassTag[CaseDef]
</span>76 <span style=''>  implicit val ThisTag: ClassTag[This]
</span>77 <span style=''>  implicit val AlternativeTag: ClassTag[Alternative]
</span>78 <span style=''>  implicit val DefDefTag: ClassTag[DefDef]
</span>79 <span style=''>  implicit val ModuleDefTag: ClassTag[ModuleDef]
</span>80 <span style=''>  implicit val NameTag: ClassTag[Name]
</span>81 <span style=''>  implicit val TemplateTag: ClassTag[Template]
</span>82 <span style=''>  implicit val BindTag: ClassTag[Bind]
</span>83 <span style=''>  implicit val NewTag: ClassTag[New]
</span>84 <span style=''>  implicit val ApplyDynamicTag: ClassTag[ApplyDynamic]
</span>85 <span style=''>  implicit val SuperTag: ClassTag[Super]
</span>86 <span style=''>  implicit val ConstantClassTag: ClassTag[Constant]
</span>87 <span style=''>  implicit val ClosureTag: ClassTag[Closure]
</span>88 <span style=''>
</span>89 <span style=''>  type ConstantTag = Int
</span>90 <span style=''>
</span>91 <span style=''>  val UnitTag: ConstantTag
</span>92 <span style=''>  val IntTag: ConstantTag
</span>93 <span style=''>  val FloatTag: ConstantTag
</span>94 <span style=''>  val NullTag: ConstantTag
</span>95 <span style=''>  val BooleanTag: ConstantTag
</span>96 <span style=''>  val ByteTag: ConstantTag
</span>97 <span style=''>  val ShortTag: ConstantTag
</span>98 <span style=''>  val CharTag: ConstantTag
</span>99 <span style=''>  val DoubleTag: ConstantTag
</span>100 <span style=''>  val LongTag: ConstantTag
</span>101 <span style=''>  val StringTag: ConstantTag
</span>102 <span style=''>  val ClazzTag: ConstantTag
</span>103 <span style=''>  val EnumTag: ConstantTag
</span>104 <span style=''>
</span>105 <span style=''>  val primitives: Primitives
</span>106 <span style=''>
</span>107 <span style=''>
</span>108 <span style=''>  val nme_This: Name
</span>109 <span style=''>  val nme_EMPTY_PACKAGE_NAME: Name
</span>110 <span style=''>  val nme_CONSTRUCTOR: Name
</span>111 <span style=''>  val nme_WILDCARD: Name
</span>112 <span style=''>  val nme_THIS: Name
</span>113 <span style=''>  val nme_PACKAGE: Name
</span>114 <span style=''>  val nme_EQEQ_LOCAL_VAR: Name
</span>115 <span style=''>  val nme_apply: Name
</span>116 <span style=''>
</span>117 <span style=''>  /* methods used to box&amp;unbox primitives ?and value classes? */
</span>118 <span style=''>  def boxMethods: Map[Symbol, Symbol] // (class, method)
</span>119 <span style=''>  def unboxMethods: Map[Symbol, Symbol]
</span>120 <span style=''>
</span>121 <span style=''>  /* dotty specific, see dotty.runtime.Arrays */
</span>122 <span style=''>  def isSyntheticArrayConstructor(s: Symbol) = </span><span style='background: #F0ADAD'>false</span><span style=''>
</span>123 <span style=''>
</span>124 <span style=''>  /*
</span>125 <span style=''>   * Collects all LabelDef nodes enclosed (directly or not) by each node.
</span>126 <span style=''>   *
</span>127 <span style=''>   * In other words, this prepares a map giving
</span>128 <span style=''>   * all labelDefs (the entry-value) having a Tree node (the entry-key) as ancestor.
</span>129 <span style=''>   * The entry-value for a LabelDef entry-key always contains the entry-key.
</span>130 <span style=''>   */
</span>131 <span style=''>  def getLabelDefOwners(t: Tree): Map[Tree, List[LabelDef]]
</span>132 <span style=''>
</span>133 <span style=''>  /*
</span>134 <span style=''>   * Implementation of those methods is very specific to how annotations are represented
</span>135 <span style=''>   *  representations for Dotc and Scalac are to different to abstract over them
</span>136 <span style=''>   */
</span>137 <span style=''>  def emitAnnotations(cw: asm.ClassVisitor, annotations: List[Annotation], bcodeStore: BCodeHelpers)(innerClasesStore: bcodeStore.BCInnerClassGen): Unit
</span>138 <span style=''>  def emitAnnotations(mw: asm.MethodVisitor, annotations: List[Annotation], bcodeStore: BCodeHelpers)(innerClasesStore: bcodeStore.BCInnerClassGen): Unit
</span>139 <span style=''>  def emitAnnotations(fw: asm.FieldVisitor, annotations: List[Annotation], bcodeStore: BCodeHelpers)(innerClasesStore: bcodeStore.BCInnerClassGen): Unit
</span>140 <span style=''>  def emitParamAnnotations(jmethod: asm.MethodVisitor, pannotss: List[List[Annotation]], bcodeStore: BCodeHelpers)(innerClasesStore: bcodeStore.BCInnerClassGen): Unit
</span>141 <span style=''>
</span>142 <span style=''>  /* means of getting class symbols from compiler */
</span>143 <span style=''>  def requiredClass[T: ClassTag]: Symbol
</span>144 <span style=''>  def requiredModule[T: ClassTag]: Symbol
</span>145 <span style=''>  def getRequiredClass(fullname: String): Symbol
</span>146 <span style=''>  def getClassIfDefined(fullname: String): Symbol
</span>147 <span style=''>
</span>148 <span style=''>  def isQualifierSafeToElide(qual: Tree): Boolean
</span>149 <span style=''>  def desugarIdent(i: Ident): Option[Select]
</span>150 <span style=''>
</span>151 <span style=''>  /* various configuration options used by backend */
</span>152 <span style=''>  def emitAsmp: Option[String]
</span>153 <span style=''>  def dumpClasses: Option[String]
</span>154 <span style=''>  def mainClass: Option[String]
</span>155 <span style=''>  def noForwarders: Boolean
</span>156 <span style=''>  def debuglevel: Int
</span>157 <span style=''>  def settings_debug: Boolean
</span>158 <span style=''>  def targetPlatform: String
</span>159 <span style=''>  def sourceFileFor(cu: CompilationUnit): String
</span>160 <span style=''>  def setMainClass(name: String): Unit
</span>161 <span style=''>  def informProgress(msg: String): Unit
</span>162 <span style=''>  def shouldEmitJumpAfterLabels: Boolean // see comment on dotty.tools.backend.jvm.LabelDefs
</span>163 <span style=''>
</span>164 <span style=''>  /* backend actually uses free names to generate stuff. This should NOT mangled */
</span>165 <span style=''>  def newTermName(prefix: String): Name
</span>166 <span style=''>
</span>167 <span style=''>  def getGenericSignature(sym: Symbol, owner:Symbol): String
</span>168 <span style=''>  def getStaticForwarderGenericSignature(sym: Symbol, moduleClass: Symbol): String
</span>169 <span style=''>
</span>170 <span style=''>  def isBox(sym: Symbol): Boolean
</span>171 <span style=''>  def isUnbox(sym: Symbol): Boolean
</span>172 <span style=''>  def isMaybeBoxed(sym: Symbol): Boolean
</span>173 <span style=''>
</span>174 <span style=''>  /** Whether an annotation should be emitted as a Java annotation
</span>175 <span style=''>    * .initialize: if 'annot' is read from pickle, atp might be un-initialized
</span>176 <span style=''>    */
</span>177 <span style=''>  def shouldEmitAnnotation(annot: Annotation): Boolean
</span>178 <span style=''>
</span>179 <span style=''>  def isRuntimeVisible(annot: Annotation): Boolean
</span>180 <span style=''>
</span>181 <span style=''>  def getSingleOutput: Option[AbstractFile]
</span>182 <span style=''>
</span>183 <span style=''>  implicit def symHelper(sym: Symbol): SymbolHelper
</span>184 <span style=''>  implicit def typeHelper(tp: Type): TypeHelper
</span>185 <span style=''>  implicit def nameHelper(n: Name): NameHelper
</span>186 <span style=''>  implicit def annotHelper(a: Annotation): AnnotationHelper
</span>187 <span style=''>  implicit def treeHelper(a: Tree): TreeHelper
</span>188 <span style=''>
</span>189 <span style=''>  implicit def constantHelper(a: Constant): ConstantHelper
</span>190 <span style=''>  implicit def positionHelper(a: Position): PositionHelper
</span>191 <span style=''>
</span>192 <span style=''>
</span>193 <span style=''>  val Assign: AssignDeconstructor
</span>194 <span style=''>  val Select: SelectDeconstructor
</span>195 <span style=''>  val Apply: ApplyDeconstructor
</span>196 <span style=''>  val If: IfDeconstructor
</span>197 <span style=''>  val ValDef: ValDefDeconstructor
</span>198 <span style=''>  val Throw: ThrowDeconstructor
</span>199 <span style=''>  val New: NewDeconstructor
</span>200 <span style=''>  val ApplyDynamic: ApplyDynamicDeconstructor
</span>201 <span style=''>  val This: ThisDeconstructor
</span>202 <span style=''>  val Ident: IdentDeconstructor
</span>203 <span style=''>  val Try: TryDeconstructor
</span>204 <span style=''>  val Return: ReturnDeconstructor
</span>205 <span style=''>  val LabelDef: LabelDeconstructor
</span>206 <span style=''>  val Literal: LiteralDeconstructor
</span>207 <span style=''>  val Typed: TypedDeconstrutor
</span>208 <span style=''>  val Super: SuperDeconstructor
</span>209 <span style=''>  val ArrayValue: ArrayValueDeconstructor
</span>210 <span style=''>  val Match: MatchDeconstructor
</span>211 <span style=''>  val Block: BlockDeconstructor
</span>212 <span style=''>  val TypeApply: TypeApplyDeconstructor
</span>213 <span style=''>  val CaseDef: CaseDeconstructor
</span>214 <span style=''>  val Alternative: AlternativeDeconstructor
</span>215 <span style=''>  val Constant: ConstantDeconstructor
</span>216 <span style=''>  val ThrownException: ThrownException
</span>217 <span style=''>  val DefDef: DefDefDeconstructor
</span>218 <span style=''>  val ModuleDef: ModuleDefDeconstructor
</span>219 <span style=''>  val Template: TemplateDeconstructor
</span>220 <span style=''>  val Bind: BindDeconstructor
</span>221 <span style=''>  val ClassDef: ClassDefDeconstructor
</span>222 <span style=''>  val Closure: ClosureDeconstructor
</span>223 <span style=''>
</span>224 <span style=''>  abstract class DeconstructorCommon[T &gt;: Null &lt;: AnyRef] {
</span>225 <span style=''>    var field: T = </span><span style='background: #AEF1AE'>null</span><span style=''>
</span>226 <span style=''>    def get: this.type = this
</span>227 <span style=''>    def isEmpty: Boolean = </span><span style='background: #AEF1AE'>field eq null</span><span style=''>
</span>228 <span style=''>    def isDefined = </span><span style='background: #F0ADAD'>!isEmpty</span><span style=''>
</span>229 <span style=''>    def unapply(s: T): this.type ={
</span>230 <span style=''>      </span><span style='background: #AEF1AE'>field = s</span><span style=''>
</span>231 <span style=''>      this
</span>232 <span style=''>    }
</span>233 <span style=''>  }
</span>234 <span style=''>
</span>235 <span style=''>  abstract class Deconstructor1Common[T &gt;: Null &lt;: AnyRef, R]{
</span>236 <span style=''>    var field: T = _
</span>237 <span style=''>    def get: R
</span>238 <span style=''>    def isEmpty: Boolean = </span><span style='background: #AEF1AE'>field eq null</span><span style=''>
</span>239 <span style=''>    def isDefined = </span><span style='background: #F0ADAD'>!isEmpty</span><span style=''>
</span>240 <span style=''>    def unapply(s: T): this.type ={
</span>241 <span style=''>      </span><span style='background: #AEF1AE'>field = s</span><span style=''>
</span>242 <span style=''>      this
</span>243 <span style=''>    }
</span>244 <span style=''>  }
</span>245 <span style=''>
</span>246 <span style=''>  abstract class ClassDefDeconstructor extends DeconstructorCommon[ClassDef] {
</span>247 <span style=''>    def _1: Modifiers
</span>248 <span style=''>    def _2: Name
</span>249 <span style=''>    def _3: List[TypeDef]
</span>250 <span style=''>    def _4: Template
</span>251 <span style=''>  }
</span>252 <span style=''>
</span>253 <span style=''>  abstract class BindDeconstructor extends DeconstructorCommon[Bind]{
</span>254 <span style=''>    def _1: Name
</span>255 <span style=''>    def _2: Tree
</span>256 <span style=''>  }
</span>257 <span style=''>
</span>258 <span style=''>  abstract class TemplateDeconstructor extends DeconstructorCommon[Template]{
</span>259 <span style=''>    def _1: List[Tree]
</span>260 <span style=''>    def _2: ValDef
</span>261 <span style=''>    def _3: List[Tree]
</span>262 <span style=''>  }
</span>263 <span style=''>
</span>264 <span style=''>  abstract class ModuleDefDeconstructor extends DeconstructorCommon[ModuleDef]{
</span>265 <span style=''>    def _1: Modifiers
</span>266 <span style=''>    def _2: Name
</span>267 <span style=''>    def _3: Tree
</span>268 <span style=''>  }
</span>269 <span style=''>
</span>270 <span style=''>  abstract class DefDefDeconstructor extends DeconstructorCommon[DefDef]{
</span>271 <span style=''>    def _1: Modifiers
</span>272 <span style=''>    def _2: Name
</span>273 <span style=''>    def _3: List[TypeDef]
</span>274 <span style=''>    def _4: List[List[ValDef]]
</span>275 <span style=''>    def _5: Tree
</span>276 <span style=''>    def _6: Tree
</span>277 <span style=''>  }
</span>278 <span style=''>
</span>279 <span style=''>  abstract class ClosureDeconstructor extends DeconstructorCommon[Closure]{
</span>280 <span style=''>    def _1: List[Tree] // environment
</span>281 <span style=''>    def _2: Tree // meth
</span>282 <span style=''>    def _3: Symbol // functionalInterface
</span>283 <span style=''>  }
</span>284 <span style=''>
</span>285 <span style=''>  abstract class ThisDeconstructor extends Deconstructor1Common[This, Name]{
</span>286 <span style=''>    def apply(s: Symbol): Tree
</span>287 <span style=''>  }
</span>288 <span style=''>
</span>289 <span style=''>  abstract class IdentDeconstructor extends Deconstructor1Common[Ident, Name]{
</span>290 <span style=''>  }
</span>291 <span style=''>
</span>292 <span style=''>  abstract class ReturnDeconstructor extends Deconstructor1Common[Return, Tree]{
</span>293 <span style=''>  }
</span>294 <span style=''>
</span>295 <span style=''>  abstract class ThrownException {
</span>296 <span style=''>    def unapply(a: Annotation): Option[Symbol]
</span>297 <span style=''>  }
</span>298 <span style=''>
</span>299 <span style=''>  abstract class ThrowDeconstructor extends Deconstructor1Common[Throw, Tree]{
</span>300 <span style=''>  }
</span>301 <span style=''>
</span>302 <span style=''>  abstract class ConstantDeconstructor extends Deconstructor1Common[Constant, Any]{
</span>303 <span style=''>  }
</span>304 <span style=''>
</span>305 <span style=''>  abstract class NewDeconstructor extends Deconstructor1Common[New, Type]{
</span>306 <span style=''>  }
</span>307 <span style=''>
</span>308 <span style=''>  abstract class AlternativeDeconstructor extends Deconstructor1Common[Alternative, List[Tree]]{
</span>309 <span style=''>  }
</span>310 <span style=''>
</span>311 <span style=''>  abstract class BlockDeconstructor extends DeconstructorCommon[Block]{
</span>312 <span style=''>    def _1: List[Tree]
</span>313 <span style=''>    def _2: Tree
</span>314 <span style=''>  }
</span>315 <span style=''>
</span>316 <span style=''>  abstract class CaseDeconstructor extends DeconstructorCommon[CaseDef]{
</span>317 <span style=''>    def _1: Tree
</span>318 <span style=''>    def _2: Tree
</span>319 <span style=''>    def _3: Tree
</span>320 <span style=''>  }
</span>321 <span style=''>
</span>322 <span style=''>  abstract class MatchDeconstructor extends DeconstructorCommon[Match]{
</span>323 <span style=''>    def _1: Tree
</span>324 <span style=''>    def _2: List[Tree]
</span>325 <span style=''>  }
</span>326 <span style=''>
</span>327 <span style=''>  abstract class LiteralDeconstructor extends Deconstructor1Common[Literal, Constant]{
</span>328 <span style=''>  }
</span>329 <span style=''>
</span>330 <span style=''>  abstract class AssignDeconstructor extends DeconstructorCommon[Assign]{
</span>331 <span style=''>    def _1: Tree
</span>332 <span style=''>    def _2: Tree
</span>333 <span style=''>  }
</span>334 <span style=''>
</span>335 <span style=''>  abstract class SelectDeconstructor extends DeconstructorCommon[Select]{
</span>336 <span style=''>    def _1: Tree
</span>337 <span style=''>    def _2: Name
</span>338 <span style=''>  }
</span>339 <span style=''>
</span>340 <span style=''>  abstract class ApplyDeconstructor extends DeconstructorCommon[Apply] {
</span>341 <span style=''>    def _1: Tree
</span>342 <span style=''>    def _2: List[Tree]
</span>343 <span style=''>  }
</span>344 <span style=''>
</span>345 <span style=''>  abstract class IfDeconstructor extends DeconstructorCommon[If]{
</span>346 <span style=''>    def _1: Tree
</span>347 <span style=''>    def _2: Tree
</span>348 <span style=''>    def _3: Tree
</span>349 <span style=''>  }
</span>350 <span style=''>
</span>351 <span style=''>  abstract class ValDefDeconstructor extends DeconstructorCommon[ValDef]{
</span>352 <span style=''>    def _1: Modifiers
</span>353 <span style=''>    def _2: Name
</span>354 <span style=''>    def _3: Tree
</span>355 <span style=''>    def _4: Tree
</span>356 <span style=''>  }
</span>357 <span style=''>
</span>358 <span style=''>
</span>359 <span style=''>  abstract class ApplyDynamicDeconstructor extends DeconstructorCommon[ApplyDynamic]{
</span>360 <span style=''>    def _1: Tree
</span>361 <span style=''>    def _2: List[Tree]
</span>362 <span style=''>  }
</span>363 <span style=''>
</span>364 <span style=''>
</span>365 <span style=''>  abstract class TryDeconstructor extends DeconstructorCommon[Try]{
</span>366 <span style=''>    def _1: Tree
</span>367 <span style=''>    def _2: List[Tree]
</span>368 <span style=''>    def _3: Tree
</span>369 <span style=''>  }
</span>370 <span style=''>
</span>371 <span style=''>  abstract class LabelDeconstructor extends DeconstructorCommon[LabelDef]{
</span>372 <span style=''>    def _1: Name
</span>373 <span style=''>    def _2: List[Symbol]
</span>374 <span style=''>    def _3: Tree
</span>375 <span style=''>  }
</span>376 <span style=''>
</span>377 <span style=''>  abstract class TypedDeconstrutor extends DeconstructorCommon[Typed]{
</span>378 <span style=''>    def _1: Tree
</span>379 <span style=''>    def _2: Tree
</span>380 <span style=''>  }
</span>381 <span style=''>
</span>382 <span style=''>  abstract class SuperDeconstructor extends DeconstructorCommon[Super]{
</span>383 <span style=''>    def _1: Tree
</span>384 <span style=''>    def _2: Name
</span>385 <span style=''>  }
</span>386 <span style=''>
</span>387 <span style=''>  abstract class ArrayValueDeconstructor extends DeconstructorCommon[ArrayValue]{
</span>388 <span style=''>    def _1: Type
</span>389 <span style=''>    def _2: List[Tree]
</span>390 <span style=''>  }
</span>391 <span style=''>
</span>392 <span style=''>  abstract class TypeApplyDeconstructor extends DeconstructorCommon[TypeApply]{
</span>393 <span style=''>    def _1: Tree
</span>394 <span style=''>    def _2: List[Tree]
</span>395 <span style=''>  }
</span>396 <span style=''>
</span>397 <span style=''>  abstract class PositionHelper {
</span>398 <span style=''>    def isDefined: Boolean
</span>399 <span style=''>    def finalPosition: Position
</span>400 <span style=''>    def line: Int
</span>401 <span style=''>  }
</span>402 <span style=''>
</span>403 <span style=''>  abstract class ConstantHelper {
</span>404 <span style=''>    def tag: ConstantTag
</span>405 <span style=''>    def longValue: Long
</span>406 <span style=''>    def doubleValue: Double
</span>407 <span style=''>    def charValue: Char
</span>408 <span style=''>    def stringValue: String
</span>409 <span style=''>    def byteValue: Byte
</span>410 <span style=''>    def booleanValue: Boolean
</span>411 <span style=''>    def shortValue: Short
</span>412 <span style=''>    def intValue: Int
</span>413 <span style=''>    def value: Any
</span>414 <span style=''>    def floatValue: Float
</span>415 <span style=''>    def typeValue: Type
</span>416 <span style=''>    def symbolValue: Symbol
</span>417 <span style=''>  }
</span>418 <span style=''>
</span>419 <span style=''>  abstract class TreeHelper{
</span>420 <span style=''>    def symbol: Symbol
</span>421 <span style=''>    def tpe: Type
</span>422 <span style=''>    def isEmpty: Boolean
</span>423 <span style=''>    def pos: Position
</span>424 <span style=''>    def exists(pred: Tree =&gt; Boolean): Boolean
</span>425 <span style=''>  }
</span>426 <span style=''>
</span>427 <span style=''>  abstract class SymbolHelper {
</span>428 <span style=''>    // names
</span>429 <span style=''>    def fullName(sep: Char): String
</span>430 <span style=''>    def fullName: String
</span>431 <span style=''>    def simpleName: Name
</span>432 <span style=''>    def javaSimpleName: String
</span>433 <span style=''>    def javaBinaryName: String
</span>434 <span style=''>    def javaClassName: String
</span>435 <span style=''>    def name: Name
</span>436 <span style=''>    def rawname: String
</span>437 <span style=''>
</span>438 <span style=''>    // types
</span>439 <span style=''>    def info: Type
</span>440 <span style=''>    def tpe: Type // todo whats the differentce between tpe and info?
</span>441 <span style=''>    def thisType: Type
</span>442 <span style=''>
</span>443 <span style=''>    // tests
</span>444 <span style=''>    def isClass: Boolean
</span>445 <span style=''>    def isType: Boolean
</span>446 <span style=''>    def isAnonymousClass: Boolean
</span>447 <span style=''>    def isConstructor: Boolean
</span>448 <span style=''>    def isAnonymousFunction: Boolean
</span>449 <span style=''>    def isMethod: Boolean
</span>450 <span style=''>    def isPublic: Boolean
</span>451 <span style=''>    def isSynthetic: Boolean
</span>452 <span style=''>    def isPackageClass: Boolean
</span>453 <span style=''>    def isModuleClass: Boolean
</span>454 <span style=''>    def isModule: Boolean
</span>455 <span style=''>    def isStrictFP: Boolean
</span>456 <span style=''>    def isLabel: Boolean
</span>457 <span style=''>    def hasPackageFlag: Boolean
</span>458 <span style=''>    def isImplClass: Boolean
</span>459 <span style=''>    def isInterface: Boolean
</span>460 <span style=''>    def isGetter: Boolean
</span>461 <span style=''>    def isSetter: Boolean
</span>462 <span style=''>    def isGetClass: Boolean
</span>463 <span style=''>    def isJavaDefined: Boolean
</span>464 <span style=''>    def isDeferred: Boolean
</span>465 <span style=''>    def isPrivate: Boolean
</span>466 <span style=''>    def getsJavaPrivateFlag: Boolean
</span>467 <span style=''>    def isFinal: Boolean
</span>468 <span style=''>    def getsJavaFinalFlag: Boolean
</span>469 <span style=''>    def isStaticMember: Boolean
</span>470 <span style=''>    def isBottomClass: Boolean
</span>471 <span style=''>    def isBridge: Boolean
</span>472 <span style=''>    def isArtifact: Boolean
</span>473 <span style=''>    def hasEnumFlag: Boolean
</span>474 <span style=''>    def hasAccessBoundary: Boolean
</span>475 <span style=''>    def isVarargsMethod: Boolean
</span>476 <span style=''>    def isDeprecated: Boolean
</span>477 <span style=''>    def isMutable: Boolean
</span>478 <span style=''>    def hasAbstractFlag: Boolean
</span>479 <span style=''>    def hasModuleFlag: Boolean
</span>480 <span style=''>    def isSynchronized: Boolean
</span>481 <span style=''>    def isNonBottomSubClass(sym: Symbol): Boolean
</span>482 <span style=''>    def hasAnnotation(sym: Symbol): Boolean
</span>483 <span style=''>    def shouldEmitForwarders: Boolean
</span>484 <span style=''>    def isJavaEntryPoint: Boolean
</span>485 <span style=''>    def isJavaDefaultMethod: Boolean
</span>486 <span style=''>    def isClassConstructor: Boolean
</span>487 <span style=''>
</span>488 <span style=''>    /**
</span>489 <span style=''>     * True for module classes of modules that are top-level or owned only by objects. Module classes
</span>490 <span style=''>     * for such objects will get a MODULE$ flag and a corresponding static initializer.
</span>491 <span style=''>     */
</span>492 <span style=''>    def isStaticModuleClass: Boolean
</span>493 <span style=''>
</span>494 <span style=''>    def isStaticConstructor: Boolean
</span>495 <span style=''>
</span>496 <span style=''>
</span>497 <span style=''>    // navigation
</span>498 <span style=''>    def owner: Symbol
</span>499 <span style=''>    def rawowner: Symbol // todo ???
</span>500 <span style=''>    def originalOwner: Symbol
</span>501 <span style=''>    def parentSymbols: List[Symbol]
</span>502 <span style=''>    def superClass: Symbol
</span>503 <span style=''>    def enclClass: Symbol
</span>504 <span style=''>    def linkedClassOfClass: Symbol
</span>505 <span style=''>    def linkedClass: Symbol
</span>506 <span style=''>    def companionClass: Symbol
</span>507 <span style=''>    def companionModule: Symbol
</span>508 <span style=''>    def companionSymbol: Symbol
</span>509 <span style=''>    def moduleClass: Symbol
</span>510 <span style=''>    def enclosingClassSym: Symbol
</span>511 <span style=''>
</span>512 <span style=''>
</span>513 <span style=''>
</span>514 <span style=''>    // members
</span>515 <span style=''>    def primaryConstructor: Symbol
</span>516 <span style=''>    def nestedClasses: List[Symbol]
</span>517 <span style=''>    def memberClasses: List[Symbol]
</span>518 <span style=''>    def annotations: List[Annotation]
</span>519 <span style=''>    def companionModuleMembers: List[Symbol]
</span>520 <span style=''>    def fieldSymbols: List[Symbol]
</span>521 <span style=''>    def methodSymbols: List[Symbol]
</span>522 <span style=''>    def serialVUID: Option[Long]
</span>523 <span style=''>
</span>524 <span style=''>
</span>525 <span style=''>    def freshLocal(cunit: CompilationUnit, name: String, tpe: Type, pos: Position, flags: Flags): Symbol
</span>526 <span style=''>
</span>527 <span style=''>    def getter(clz: Symbol): Symbol
</span>528 <span style=''>    def setter(clz: Symbol): Symbol
</span>529 <span style=''>
</span>530 <span style=''>    def moduleSuffix: String
</span>531 <span style=''>    def outputDirectory: AbstractFile
</span>532 <span style=''>    def pos: Position
</span>533 <span style=''>
</span>534 <span style=''>    def throwsAnnotations: List[Symbol]
</span>535 <span style=''>
</span>536 <span style=''>    /**
</span>537 <span style=''>     * All interfaces implemented by a class, except for those inherited through the superclass.
</span>538 <span style=''>     *
</span>539 <span style=''>     */
</span>540 <span style=''>    def superInterfaces: List[Symbol]
</span>541 <span style=''>
</span>542 <span style=''>    /**
</span>543 <span style=''>     * True for module classes of package level objects. The backend will generate a mirror class for
</span>544 <span style=''>     * such objects.
</span>545 <span style=''>     */
</span>546 <span style=''>    def isTopLevelModuleClass: Boolean
</span>547 <span style=''>
</span>548 <span style=''>    /**
</span>549 <span style=''>     * This is basically a re-implementation of sym.isStaticOwner, but using the originalOwner chain.
</span>550 <span style=''>     *
</span>551 <span style=''>     * The problem is that we are interested in a source-level property. Various phases changed the
</span>552 <span style=''>     * symbol's properties in the meantime, mostly lambdalift modified (destructively) the owner.
</span>553 <span style=''>     * Therefore, `sym.isStatic` is not what we want. For example, in
</span>554 <span style=''>     *   object T { def f { object U } }
</span>555 <span style=''>     * the owner of U is T, so UModuleClass.isStatic is true. Phase travel does not help here.
</span>556 <span style=''>     */
</span>557 <span style=''>    def isOriginallyStaticOwner: Boolean
</span>558 <span style=''>
</span>559 <span style=''>
</span>560 <span style=''>    def samMethod(): Symbol
</span>561 <span style=''>  }
</span>562 <span style=''>
</span>563 <span style=''>  abstract class TypeHelper {
</span>564 <span style=''>    def &lt;:&lt;(other: Type): Boolean
</span>565 <span style=''>    def =:=(other: Type): Boolean
</span>566 <span style=''>    def paramTypes: List[Type]
</span>567 <span style=''>    def params: List[Symbol]
</span>568 <span style=''>    def resultType: Type
</span>569 <span style=''>    def memberInfo(s: Symbol): Type
</span>570 <span style=''>    def membersBasedOnFlags(excludedFlags: Flags, requiredFlags: Flags): List[Symbol]
</span>571 <span style=''>    def members: List[Symbol]
</span>572 <span style=''>    def decls: List[Symbol]
</span>573 <span style=''>    def underlying: Type
</span>574 <span style=''>    def parents: List[Type]
</span>575 <span style=''>    def summaryString: String
</span>576 <span style=''>    def typeSymbol: Symbol
</span>577 <span style=''>    def member(string: Name): Symbol
</span>578 <span style=''>    /**
</span>579 <span style=''>     * This method returns the BType for a type reference, for example a parameter type.
</span>580 <span style=''>     *
</span>581 <span style=''>     * If the result is a ClassBType for a nested class, it is added to the innerClassBufferASM.
</span>582 <span style=''>     *
</span>583 <span style=''>     * If `t` references a class, toTypeKind ensures that the class is not an implementation class.
</span>584 <span style=''>     * See also comment on getClassBTypeAndRegisterInnerClass, which is invoked for implementation
</span>585 <span style=''>     * classes.
</span>586 <span style=''>     */
</span>587 <span style=''>    def toTypeKind(ctx: BCodeHelpers)(storage: ctx.BCInnerClassGen): ctx.bTypes.BType
</span>588 <span style=''>
</span>589 <span style=''>    def isFinalType: Boolean
</span>590 <span style=''>  }
</span>591 <span style=''>
</span>592 <span style=''>  abstract class Primitives {
</span>593 <span style=''>    def getPrimitive(app: Apply, reciever: Type): Int
</span>594 <span style=''>    def isPrimitive(fun: Tree): Boolean
</span>595 <span style=''>    def getPrimitive(sym: Symbol): Int
</span>596 <span style=''>  }
</span>597 <span style=''>
</span>598 <span style=''>  abstract class NameHelper {
</span>599 <span style=''>    def isTypeName: Boolean
</span>600 <span style=''>    def isTermName: Boolean
</span>601 <span style=''>    def startsWith(s: String): Boolean
</span>602 <span style=''>    def mangledString: String
</span>603 <span style=''>  }
</span>604 <span style=''>
</span>605 <span style=''>  abstract class AnnotationHelper{
</span>606 <span style=''>    def atp: Type
</span>607 <span style=''>    def symbol: Symbol
</span>608 <span style=''>    def args: List[Tree]
</span>609 <span style=''>    def assocs: List[(Name, /* ClassfileAnnotArg*/ Object)]
</span>610 <span style=''>  }
</span>611 <span style=''>
</span>612 <span style=''>  def debuglog(msg: =&gt; String): Unit
</span>613 <span style=''>  def log(msg: =&gt; String): Unit
</span>614 <span style=''>  def error(pos: Position, msg: String): Unit // reporter.error
</span>615 <span style=''>  def warning(pos: Position, msg: String): Unit // reporter.warning
</span>616 <span style=''>  def abort(msg: String): Nothing
</span>617 <span style=''>
</span>618 <span style=''>  val ExcludedForwarderFlags: Flags
</span>619 <span style=''>  val Flag_METHOD: Flags
</span>620 <span style=''>  val Flag_SYNTHETIC: Flags
</span>621 <span style=''>
</span>622 <span style=''>  abstract class Caches {
</span>623 <span style=''>    def recordCache[T &lt;: Clearable](cache: T): T
</span>624 <span style=''>    def newWeakMap[K, V](): collection.mutable.WeakHashMap[K, V]
</span>625 <span style=''>    def newMap[K, V](): collection.mutable.HashMap[K, V]
</span>626 <span style=''>    def newSet[K](): collection.mutable.Set[K]
</span>627 <span style=''>    def newWeakSet[K &gt;: Null &lt;: AnyRef](): reflect.internal.util.WeakHashSet[K]
</span>628 <span style=''>    def newAnyRefMap[K &lt;: AnyRef, V](): collection.mutable.AnyRefMap[K, V]
</span>629 <span style=''>  }
</span>630 <span style=''>
</span>631 <span style=''>  def perRunCaches: Caches
</span>632 <span style=''>
</span>633 <span style=''>  def MODULE_INSTANCE_FIELD: String
</span>634 <span style=''>
</span>635 <span style=''>  def dropModule(str: String): String
</span>636 <span style=''>
</span>637 <span style=''>/*  Returns a ScalaSignature annotation if it must be added to this class, none otherwise.
</span>638 <span style=''> *  This annotation must be added to the class' annotations list when generating them.
</span>639 <span style=''> *
</span>640 <span style=''> *  Depending on whether the returned option is defined, it adds to `jclass` one of:
</span>641 <span style=''> *    (a) the ScalaSig marker attribute
</span>642 <span style=''> *        (indicating that a scala-signature-annotation aka pickle is present in this class); or
</span>643 <span style=''> *    (b) the Scala marker attribute
</span>644 <span style=''> *        (indicating that a scala-signature-annotation aka pickle is to be found in another file).
</span>645 <span style=''> *
</span>646 <span style=''> *
</span>647 <span style=''> *  @param jclassName The class file that is being readied.
</span>648 <span style=''> *  @param sym    The symbol for which the signature has been entered in the symData map.
</span>649 <span style=''> *                This is different than the symbol
</span>650 <span style=''> *                that is being generated in the case of a mirror class.
</span>651 <span style=''> *  @return       An option that is:
</span>652 <span style=''> *                - defined and contains an AnnotationInfo of the ScalaSignature type,
</span>653 <span style=''> *                  instantiated with the pickle signature for sym.
</span>654 <span style=''> *                - empty if the jclass/sym pair must not contain a pickle.
</span>655 <span style=''> *
</span>656 <span style=''> *  must-single-thread
</span>657 <span style=''> */
</span>658 <span style=''>  def getAnnotPickle(jclassName: String, sym: Symbol): Option[Annotation]
</span>659 <span style=''>}
</span>660 <span style=''>
</span>661 <span style=''>abstract class BackendInterfaceDefinitions { self: BackendInterface =&gt;
</span>662 <span style=''>  val nme_valueOf: Name
</span>663 <span style=''>
</span>664 <span style=''>  /* magic instances */
</span>665 <span style=''>  val NoPosition: Position
</span>666 <span style=''>  val NoSymbol: Symbol
</span>667 <span style=''>  val EmptyTree: Tree
</span>668 <span style=''>  val NothingClass: Symbol
</span>669 <span style=''>  val NullClass: Symbol
</span>670 <span style=''>  val ObjectClass: Symbol
</span>671 <span style=''>  val Object_isInstanceOf: Symbol
</span>672 <span style=''>  val Object_asInstanceOf: Symbol
</span>673 <span style=''>  val Object_equals: Symbol
</span>674 <span style=''>  val ArrayClass: Symbol
</span>675 <span style=''>
</span>676 <span style=''>  val UnitClass: Symbol
</span>677 <span style=''>  val BooleanClass: Symbol
</span>678 <span style=''>  val CharClass: Symbol
</span>679 <span style=''>  val ShortClass: Symbol
</span>680 <span style=''>  val ClassClass: Symbol
</span>681 <span style=''>  val ByteClass: Symbol
</span>682 <span style=''>  val IntClass: Symbol
</span>683 <span style=''>  val LongClass: Symbol
</span>684 <span style=''>  val FloatClass: Symbol
</span>685 <span style=''>  val DoubleClass: Symbol
</span>686 <span style=''>
</span>687 <span style=''>  // Class symbols used in backend.
</span>688 <span style=''>  // Vals becouse they are to frequent in scala programs so that they are already loaded by backend
</span>689 <span style=''>
</span>690 <span style=''>  lazy val NativeAttr: Symbol = requiredClass[scala.native]
</span>691 <span style=''>  lazy val TransientAttr = requiredClass[scala.transient]
</span>692 <span style=''>  lazy val VolatileAttr = requiredClass[scala.volatile]
</span>693 <span style=''>  lazy val LambdaMetaFactory = getClassIfDefined(&quot;java.lang.invoke.LambdaMetafactory&quot;)
</span>694 <span style=''>  lazy val MethodHandle = getClassIfDefined(&quot;java.lang.invoke.MethodHandle&quot;)
</span>695 <span style=''>
</span>696 <span style=''>  val ScalaATTRName: String = </span><span style='background: #AEF1AE'>&quot;Scala&quot;</span><span style=''>
</span>697 <span style=''>  val ScalaSignatureATTRName: String = </span><span style='background: #AEF1AE'>&quot;ScalaSig&quot;</span><span style=''>
</span>698 <span style=''>  val MetafactoryName: String = </span><span style='background: #AEF1AE'>&quot;metafactory&quot;</span><span style=''>
</span>699 <span style=''>
</span>700 <span style=''>  def doLabmdasFollowJVMMetafactoryOrder: Boolean = </span><span style='background: #AEF1AE'>true</span><span style=''>
</span>701 <span style=''>
</span>702 <span style=''>  val BoxedBooleanClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Boolean]</span><span style=''>
</span>703 <span style=''>  val BoxedByteClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Byte]</span><span style=''>
</span>704 <span style=''>  val BoxedShortClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Short]</span><span style=''>
</span>705 <span style=''>  val BoxedCharacterClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Character]</span><span style=''>
</span>706 <span style=''>  val BoxedIntClass: Symbol  = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Integer]</span><span style=''>
</span>707 <span style=''>  val BoxedLongClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Long]</span><span style=''>
</span>708 <span style=''>  val BoxedFloatClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Float]</span><span style=''>
</span>709 <span style=''>  val BoxedDoubleClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Double]</span><span style=''>
</span>710 <span style=''>  val StringClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.String]</span><span style=''>
</span>711 <span style=''>  val JavaStringBuilderClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.StringBuilder]</span><span style=''>
</span>712 <span style=''>  val JavaStringBufferClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.StringBuffer]</span><span style=''>
</span>713 <span style=''>  val JavaCharSequenceClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.CharSequence]</span><span style=''>
</span>714 <span style=''>  val ThrowableClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Throwable]</span><span style=''>
</span>715 <span style=''>  val JavaCloneableClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Cloneable]</span><span style=''>
</span>716 <span style=''>  val NullPointerExceptionClass: Symbol  = </span><span style='background: #AEF1AE'>requiredClass[java.lang.NullPointerException]</span><span style=''>
</span>717 <span style=''>  val JavaSerializableClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.io.Serializable]</span><span style=''>
</span>718 <span style=''>  val SerializableClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[scala.Serializable]</span><span style=''>
</span>719 <span style=''>  val ClassCastExceptionClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.ClassCastException]</span><span style=''>
</span>720 <span style=''>
</span>721 <span style=''>  val ClassfileAnnotationClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[scala.annotation.ClassfileAnnotation]</span><span style=''>
</span>722 <span style=''>  val BoxedNumberClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[java.lang.Number]</span><span style=''>
</span>723 <span style=''>  val ThrowsClass: Symbol = </span><span style='background: #AEF1AE'>requiredClass[scala.throws[_]]</span><span style=''>
</span>724 <span style=''>
</span>725 <span style=''>  // Module symbols used in backend
</span>726 <span style=''>  val StringModule: Symbol = </span><span style='background: #AEF1AE'>StringClass.linkedClassOfClass</span><span style=''>
</span>727 <span style=''>  val ScalaRunTimeModule: Symbol = </span><span style='background: #AEF1AE'>requiredModule[scala.runtime.ScalaRunTime.type]</span><span style=''>
</span>728 <span style=''>
</span>729 <span style=''>
</span>730 <span style=''>  // types used in backend
</span>731 <span style=''>
</span>732 <span style=''>  val Object_Type: Type
</span>733 <span style=''>  val Throwable_Type: Type
</span>734 <span style=''>  // methods used in backend
</span>735 <span style=''>
</span>736 <span style=''>  def isArrayClone(fun: Tree): Boolean
</span>737 <span style=''>  val hashMethodSym: Symbol
</span>738 <span style=''>  val externalEqualsNumNum: Symbol
</span>739 <span style=''>  val externalEqualsNumChar: Symbol
</span>740 <span style=''>  val externalEqualsNumObject: Symbol
</span>741 <span style=''>  val externalEquals: Symbol
</span>742 <span style=''>
</span>743 <span style=''>  val MaxFunctionArity: Int
</span>744 <span style=''>  val FunctionClass: Array[Symbol]
</span>745 <span style=''>  val AbstractFunctionClass: Array[Symbol]
</span>746 <span style=''>  val PartialFunctionClass: Symbol
</span>747 <span style=''>  val AbstractPartialFunctionClass: Symbol
</span>748 <span style=''>
</span>749 <span style=''>  /* The Object =&gt; String overload. */
</span>750 <span style=''>  val String_valueOf: Symbol
</span>751 <span style=''>
</span>752 <span style=''>  def isNull(t: Tree): Boolean = t match {
</span>753 <span style=''>    case Literal(Constant(null)) =&gt; </span><span style='background: #AEF1AE'>true</span><span style=''>
</span>754 <span style=''>    case _ =&gt; </span><span style='background: #AEF1AE'>false</span><span style=''>
</span>755 <span style=''>  }
</span>756 <span style=''>  def isLiteral(t: Tree): Boolean = t match {
</span>757 <span style=''>    case Literal(_) =&gt; </span><span style='background: #AEF1AE'>true</span><span style=''>
</span>758 <span style=''>    case _ =&gt; </span><span style='background: #AEF1AE'>false</span><span style=''>
</span>759 <span style=''>  }
</span>760 <span style=''>  def isNonNullExpr(t: Tree): Boolean = </span><span style='background: #AEF1AE'>isLiteral(t) || ((t.symbol ne null) &amp;&amp; t.symbol.isModule)</span><span style=''>
</span>761 <span style=''>  def ifOneIsNull(l: Tree, r: Tree): Tree = if (</span><span style='background: #AEF1AE'>isNull(l)</span><span style=''>) </span><span style='background: #AEF1AE'>r</span><span style=''> else </span><span style='background: #AEF1AE'>if (isNull(r)) l else null</span><span style=''>
</span>762 <span style=''>
</span>763 <span style=''>  private val primitiveCompilationUnits = </span><span style='background: #AEF1AE'>Set(
</span>764 <span style=''></span><span style='background: #AEF1AE'>    &quot;Unit.scala&quot;,
</span>765 <span style=''></span><span style='background: #AEF1AE'>    &quot;Boolean.scala&quot;,
</span>766 <span style=''></span><span style='background: #AEF1AE'>    &quot;Char.scala&quot;,
</span>767 <span style=''></span><span style='background: #AEF1AE'>    &quot;Byte.scala&quot;,
</span>768 <span style=''></span><span style='background: #AEF1AE'>    &quot;Short.scala&quot;,
</span>769 <span style=''></span><span style='background: #AEF1AE'>    &quot;Int.scala&quot;,
</span>770 <span style=''></span><span style='background: #AEF1AE'>    &quot;Float.scala&quot;,
</span>771 <span style=''></span><span style='background: #AEF1AE'>    &quot;Long.scala&quot;,
</span>772 <span style=''></span><span style='background: #AEF1AE'>    &quot;Double.scala&quot;
</span>773 <span style=''></span><span style='background: #AEF1AE'>  )</span><span style=''>
</span>774 <span style=''>
</span>775 <span style=''>  def currentUnit: CompilationUnit
</span>776 <span style=''>
</span>777 <span style=''>  /**
</span>778 <span style=''>   * True if the current compilation unit is of a primitive class (scala.Boolean et al).
</span>779 <span style=''>   * Used only in assertions.
</span>780 <span style=''>   */
</span>781 <span style=''>  def isCompilingPrimitive = {
</span>782 <span style=''>    </span><span style='background: #F0ADAD'>primitiveCompilationUnits(sourceFileFor(currentUnit))</span><span style=''>
</span>783 <span style=''>  }
</span>784 <span style=''>
</span>785 <span style=''>  def isCompilingArray = {
</span>786 <span style=''>    </span><span style='background: #AEF1AE'>sourceFileFor(currentUnit) == &quot;Array.scala&quot;</span><span style=''>
</span>787 <span style=''>  }
</span>788 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Code</th>
      </tr><tr>
        <td>
          122
        </td>
        <td>
          3968
        </td>
        <td>
          3967
          -
          3972
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          3969
        </td>
        <td>
          8141
          -
          8145
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          null
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          3970
        </td>
        <td>
          8203
          -
          8216
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.eq
        </td>
        <td style="background: #AEF1AE">
          DeconstructorCommon.this.field.eq(null)
        </td>
      </tr><tr>
        <td>
          228
        </td>
        <td>
          3971
        </td>
        <td>
          8237
          -
          8245
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td style="background: #F0ADAD">
          DeconstructorCommon.this.isEmpty.unary_!
        </td>
      </tr><tr>
        <td>
          230
        </td>
        <td>
          3972
        </td>
        <td>
          8288
          -
          8297
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.DeconstructorCommon.field_=
        </td>
        <td style="background: #AEF1AE">
          DeconstructorCommon.this.field_=(s)
        </td>
      </tr><tr>
        <td>
          238
        </td>
        <td>
          3973
        </td>
        <td>
          8446
          -
          8459
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.eq
        </td>
        <td style="background: #AEF1AE">
          Deconstructor1Common.this.field.eq(null)
        </td>
      </tr><tr>
        <td>
          239
        </td>
        <td>
          3974
        </td>
        <td>
          8480
          -
          8488
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td style="background: #F0ADAD">
          Deconstructor1Common.this.isEmpty.unary_!
        </td>
      </tr><tr>
        <td>
          241
        </td>
        <td>
          3975
        </td>
        <td>
          8531
          -
          8540
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.Deconstructor1Common.field_=
        </td>
        <td style="background: #AEF1AE">
          Deconstructor1Common.this.field_=(s)
        </td>
      </tr><tr>
        <td>
          696
        </td>
        <td>
          3976
        </td>
        <td>
          21588
          -
          21595
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          &quot;Scala&quot;
        </td>
      </tr><tr>
        <td>
          697
        </td>
        <td>
          3977
        </td>
        <td>
          21635
          -
          21645
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          &quot;ScalaSig&quot;
        </td>
      </tr><tr>
        <td>
          698
        </td>
        <td>
          3978
        </td>
        <td>
          21678
          -
          21691
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          &quot;metafactory&quot;
        </td>
      </tr><tr>
        <td>
          700
        </td>
        <td>
          3979
        </td>
        <td>
          21745
          -
          21749
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          702
        </td>
        <td>
          3980
        </td>
        <td>
          21785
          -
          21817
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Boolean]((ClassTag.apply[Boolean](classOf[java.lang.Boolean]): scala.reflect.ClassTag[Boolean]))
        </td>
      </tr><tr>
        <td>
          703
        </td>
        <td>
          3981
        </td>
        <td>
          21849
          -
          21878
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Byte]((ClassTag.apply[Byte](classOf[java.lang.Byte]): scala.reflect.ClassTag[Byte]))
        </td>
      </tr><tr>
        <td>
          704
        </td>
        <td>
          3982
        </td>
        <td>
          21911
          -
          21941
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Short]((ClassTag.apply[Short](classOf[java.lang.Short]): scala.reflect.ClassTag[Short]))
        </td>
      </tr><tr>
        <td>
          705
        </td>
        <td>
          3983
        </td>
        <td>
          21978
          -
          22012
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Character]((ClassTag.apply[Character](classOf[java.lang.Character]): scala.reflect.ClassTag[Character]))
        </td>
      </tr><tr>
        <td>
          706
        </td>
        <td>
          3984
        </td>
        <td>
          22044
          -
          22076
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Integer]((ClassTag.apply[Integer](classOf[java.lang.Integer]): scala.reflect.ClassTag[Integer]))
        </td>
      </tr><tr>
        <td>
          707
        </td>
        <td>
          3985
        </td>
        <td>
          22108
          -
          22137
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Long]((ClassTag.apply[Long](classOf[java.lang.Long]): scala.reflect.ClassTag[Long]))
        </td>
      </tr><tr>
        <td>
          708
        </td>
        <td>
          3986
        </td>
        <td>
          22170
          -
          22200
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Float]((ClassTag.apply[Float](classOf[java.lang.Float]): scala.reflect.ClassTag[Float]))
        </td>
      </tr><tr>
        <td>
          709
        </td>
        <td>
          3987
        </td>
        <td>
          22234
          -
          22265
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Double]((ClassTag.apply[Double](classOf[java.lang.Double]): scala.reflect.ClassTag[Double]))
        </td>
      </tr><tr>
        <td>
          710
        </td>
        <td>
          3988
        </td>
        <td>
          22294
          -
          22325
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[String]((ClassTag.apply[String](classOf[java.lang.String]): scala.reflect.ClassTag[String]))
        </td>
      </tr><tr>
        <td>
          711
        </td>
        <td>
          3989
        </td>
        <td>
          22365
          -
          22403
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[StringBuilder]((ClassTag.apply[StringBuilder](classOf[java.lang.StringBuilder]): scala.reflect.ClassTag[StringBuilder]))
        </td>
      </tr><tr>
        <td>
          712
        </td>
        <td>
          3990
        </td>
        <td>
          22442
          -
          22479
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[StringBuffer]((ClassTag.apply[StringBuffer](classOf[java.lang.StringBuffer]): scala.reflect.ClassTag[StringBuffer]))
        </td>
      </tr><tr>
        <td>
          713
        </td>
        <td>
          3991
        </td>
        <td>
          22518
          -
          22555
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[CharSequence]((ClassTag.apply[CharSequence](classOf[java.lang.CharSequence]): scala.reflect.ClassTag[CharSequence]))
        </td>
      </tr><tr>
        <td>
          714
        </td>
        <td>
          3992
        </td>
        <td>
          22587
          -
          22621
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Throwable]((ClassTag.apply[Throwable](classOf[java.lang.Throwable]): scala.reflect.ClassTag[Throwable]))
        </td>
      </tr><tr>
        <td>
          715
        </td>
        <td>
          3993
        </td>
        <td>
          22657
          -
          22691
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Cloneable]((ClassTag.apply[Cloneable](classOf[java.lang.Cloneable]): scala.reflect.ClassTag[Cloneable]))
        </td>
      </tr><tr>
        <td>
          716
        </td>
        <td>
          3994
        </td>
        <td>
          22735
          -
          22780
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[NullPointerException]((ClassTag.apply[NullPointerException](classOf[java.lang.NullPointerException]): scala.reflect.ClassTag[NullPointerException]))
        </td>
      </tr><tr>
        <td>
          717
        </td>
        <td>
          3995
        </td>
        <td>
          22819
          -
          22854
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[java.io.Serializable]((ClassTag.apply[java.io.Serializable](classOf[java.io.Serializable]): scala.reflect.ClassTag[java.io.Serializable]))
        </td>
      </tr><tr>
        <td>
          718
        </td>
        <td>
          3996
        </td>
        <td>
          22889
          -
          22922
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Serializable]((ClassTag.apply[Serializable](classOf[scala.Serializable]): scala.reflect.ClassTag[Serializable]))
        </td>
      </tr><tr>
        <td>
          719
        </td>
        <td>
          3997
        </td>
        <td>
          22963
          -
          23006
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[ClassCastException]((ClassTag.apply[ClassCastException](classOf[java.lang.ClassCastException]): scala.reflect.ClassTag[ClassCastException]))
        </td>
      </tr><tr>
        <td>
          721
        </td>
        <td>
          3998
        </td>
        <td>
          23049
          -
          23100
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[scala.annotation.ClassfileAnnotation]((ClassTag.apply[scala.annotation.ClassfileAnnotation](classOf[scala.annotation.ClassfileAnnotation]): scala.reflect.ClassTag[scala.annotation.ClassfileAnnotation]))
        </td>
      </tr><tr>
        <td>
          722
        </td>
        <td>
          3999
        </td>
        <td>
          23134
          -
          23165
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[Number]((ClassTag.apply[Number](classOf[java.lang.Number]): scala.reflect.ClassTag[Number]))
        </td>
      </tr><tr>
        <td>
          723
        </td>
        <td>
          4000
        </td>
        <td>
          23194
          -
          23224
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredClass[throws[_]]((ClassTag.apply[throws[_]](classOf[scala.throws]): scala.reflect.ClassTag[throws[_]]))
        </td>
      </tr><tr>
        <td>
          726
        </td>
        <td>
          4002
        </td>
        <td>
          23291
          -
          23321
        </td>
        <td>
          Select
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.SymbolHelper.linkedClassOfClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.symHelper(BackendInterfaceDefinitions.this.StringClass).linkedClassOfClass
        </td>
      </tr><tr>
        <td>
          726
        </td>
        <td>
          4001
        </td>
        <td>
          23291
          -
          23302
        </td>
        <td>
          Select
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterfaceDefinitions.StringClass
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.StringClass
        </td>
      </tr><tr>
        <td>
          727
        </td>
        <td>
          4003
        </td>
        <td>
          23357
          -
          23404
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.requiredModule
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.requiredModule[runtime.ScalaRunTime.type]((ClassTag.apply[runtime.ScalaRunTime.type](classOf[scala.runtime.ScalaRunTime$]): scala.reflect.ClassTag[runtime.ScalaRunTime.type]))
        </td>
      </tr><tr>
        <td>
          753
        </td>
        <td>
          4004
        </td>
        <td>
          24055
          -
          24059
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          754
        </td>
        <td>
          4005
        </td>
        <td>
          24074
          -
          24079
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          757
        </td>
        <td>
          4006
        </td>
        <td>
          24153
          -
          24157
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          758
        </td>
        <td>
          4007
        </td>
        <td>
          24172
          -
          24177
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          760
        </td>
        <td>
          4009
        </td>
        <td>
          24261
          -
          24269
        </td>
        <td>
          Select
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.TreeHelper.symbol
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.treeHelper(t).symbol
        </td>
      </tr><tr>
        <td>
          760
        </td>
        <td>
          4012
        </td>
        <td>
          24222
          -
          24279
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.isLiteral(t).||(BackendInterfaceDefinitions.this.treeHelper(t).symbol.ne(null).&amp;&amp;(BackendInterfaceDefinitions.this.symHelper(BackendInterfaceDefinitions.this.treeHelper(t).symbol).isModule))
        </td>
      </tr><tr>
        <td>
          760
        </td>
        <td>
          4011
        </td>
        <td>
          24239
          -
          24278
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.treeHelper(t).symbol.ne(null).&amp;&amp;(BackendInterfaceDefinitions.this.symHelper(BackendInterfaceDefinitions.this.treeHelper(t).symbol).isModule)
        </td>
      </tr><tr>
        <td>
          760
        </td>
        <td>
          4008
        </td>
        <td>
          24252
          -
          24256
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          null
        </td>
      </tr><tr>
        <td>
          760
        </td>
        <td>
          4010
        </td>
        <td>
          24261
          -
          24278
        </td>
        <td>
          Select
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.SymbolHelper.isModule
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.symHelper(BackendInterfaceDefinitions.this.treeHelper(t).symbol).isModule
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4013
        </td>
        <td>
          24328
          -
          24337
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterfaceDefinitions.isNull
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.isNull(l)
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4016
        </td>
        <td>
          24361
          -
          24362
        </td>
        <td>
          Ident
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterfaceDefinitions.l
        </td>
        <td style="background: #AEF1AE">
          l
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4015
        </td>
        <td>
          24350
          -
          24359
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterfaceDefinitions.isNull
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.isNull(r)
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4018
        </td>
        <td>
          24368
          -
          24372
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          null
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4014
        </td>
        <td>
          24339
          -
          24340
        </td>
        <td>
          Ident
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterfaceDefinitions.r
        </td>
        <td style="background: #AEF1AE">
          r
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4017
        </td>
        <td>
          24368
          -
          24372
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          null
        </td>
      </tr><tr>
        <td>
          761
        </td>
        <td>
          4019
        </td>
        <td>
          24346
          -
          24372
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          if (BackendInterfaceDefinitions.this.isNull(r))
  l
else
  null
        </td>
      </tr><tr>
        <td>
          763
        </td>
        <td>
          4020
        </td>
        <td>
          24416
          -
          24591
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.Set.apply[String](&quot;Unit.scala&quot;, &quot;Boolean.scala&quot;, &quot;Char.scala&quot;, &quot;Byte.scala&quot;, &quot;Short.scala&quot;, &quot;Int.scala&quot;, &quot;Float.scala&quot;, &quot;Long.scala&quot;, &quot;Double.scala&quot;)
        </td>
      </tr><tr>
        <td>
          782
        </td>
        <td>
          4022
        </td>
        <td>
          24821
          -
          24847
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterface.sourceFileFor
        </td>
        <td style="background: #F0ADAD">
          BackendInterfaceDefinitions.this.sourceFileFor(BackendInterfaceDefinitions.this.currentUnit)
        </td>
      </tr><tr>
        <td>
          782
        </td>
        <td>
          4021
        </td>
        <td>
          24835
          -
          24846
        </td>
        <td>
          Select
        </td>
        <td>
          scala.tools.nsc.backend.jvm.BackendInterfaceDefinitions.currentUnit
        </td>
        <td style="background: #F0ADAD">
          BackendInterfaceDefinitions.this.currentUnit
        </td>
      </tr><tr>
        <td>
          782
        </td>
        <td>
          4023
        </td>
        <td>
          24795
          -
          24848
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSetLike.apply
        </td>
        <td style="background: #F0ADAD">
          BackendInterfaceDefinitions.this.primitiveCompilationUnits.apply(BackendInterfaceDefinitions.this.sourceFileFor(BackendInterfaceDefinitions.this.currentUnit))
        </td>
      </tr><tr>
        <td>
          786
        </td>
        <td>
          4024
        </td>
        <td>
          24885
          -
          24928
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td style="background: #AEF1AE">
          BackendInterfaceDefinitions.this.sourceFileFor(BackendInterfaceDefinitions.this.currentUnit).==(&quot;Array.scala&quot;)
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>